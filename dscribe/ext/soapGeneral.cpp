/*Copyright 2019 DScribe developers

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <map>
#include <set>
#include <algorithm>
#include <iostream>
#include "soapGeneral.h"
#include "weighting.h"

#define tot (double*) malloc(sizeof(double)*nAtoms);
#define totrs (double*) malloc(sizeof(double)*nAtoms*rsize);
#define sd sizeof(double)
#define PI 3.14159265359

double* factorListSet()
{
 double* c = (double* ) malloc(sd*1326);
 c[0]= 0.2820947917738781;
 c[1]= 0.4886025119029199;
 c[2]= 0.3454941494713355;
 c[3]= 0.6307831305050401;
 c[4]= 0.2575161346821264;
 c[5]= 0.1287580673410632;
 c[6]= 0.7463526651802308;
 c[7]= 0.2154534560761004;
 c[8]= 0.06813236509555216;
 c[9]= 0.02781492157551894;
 c[10]= 0.8462843753216345;
 c[11]= 0.189234939151512;
 c[12]= 0.04460310290381928;
 c[13]= 0.0119206806752224;
 c[14]= 0.004214597070904597;
 c[15]= 0.9356025796273888;
 c[16]= 0.1708168792406481;
 c[17]= 0.03228135587163618;
 c[18]= 0.006589404174225528;
 c[19]= 0.001553137458524604;
 c[20]= 0.000491145188826305;
 c[21]= 1.017107236282055;
 c[22]= 0.156943053829006;
 c[23]= 0.02481487565210345;
 c[24]= 0.00413581260868391;
 c[25]= 0.0007550926197968211;
 c[26]= 0.0001609862874555169;
 c[27]= 4.647273819914057e-05;
 c[28]= 1.092548430592079;
 c[29]= 0.1459979252047546;
 c[30]= 0.01986780112537067;
 c[31]= 0.002809731380603064;
 c[32]= 0.000423582943233983;
 c[33]= 7.059715720566384e-05;
 c[34]= 1.384524162291759e-05;
 c[35]= 3.700296470718546e-06;
 c[36]= 1.16310662292032;
 c[37]= 0.1370734300516571;
 c[38]= 0.01638340851773374;
 c[39]= 0.002016658181771346;
 c[40]= 0.0002603494517664451;
 c[41]= 3.610397299549447e-05;
 c[42]= 5.5709639801457e-06;
 c[43]= 1.017114212991521e-06;
 c[44]= 2.542785532478802e-07;
 c[45]= 1.229622689841484;
 c[46]= 0.1296136120840625;
 c[47]= 0.01381685747288017;
 c[48]= 0.001507542743711658;
 c[49]= 0.0001706956026696042;
 c[50]= 2.040202677982873e-05;
 c[51]= 2.633890331571813e-06;
 c[52]= 3.801693229872348e-07;
 c[53]= 6.519850100689623e-08;
 c[54]= 1.536743406172475e-08;
 c[55]= 1.292720736456603;
 c[56]= 0.1232560860553381;
 c[57]= 0.01186032241055152;
 c[58]= 0.001163000296325078;
 c[59]= 0.0001174807708647752;
 c[60]= 1.23835605735013e-05;
 c[61]= 1.384524162291759e-06;
 c[62]= 1.678982165396686e-07;
 c[63]= 2.284805329141706e-08;
 c[64]= 3.706443675005072e-09;
 c[65]=0.0;
 c[66]= 1.352879094951503;
 c[67]= 0.1177530108203118;
 c[68]= 0.01032762224375018;
 c[69]= 0.0009200577156223507;
 c[70]= 8.398939417550579e-05;
 c[71]= 7.936251776977327e-06;
 c[72]= 7.858060197418365e-07;
 c[73]= 8.283122738184806e-08;
 c[74]= 9.501393408603022e-09;
 c[75]= 1.226624614576148e-09;
 c[76]=0.0;
 c[77]=0.0;
 c[78]= 1.410473958869391;
 c[79]= 0.112928295511954;
 c[80]= 0.00910002138117768;
 c[81]= 0.0007430136344100779;
 c[82]= 6.191780286750648e-05;
 c[83]= 5.309407793455069e-06;
 c[84]= 4.729996402327689e-07;
 c[85]= 4.430047519252571e-08;
 c[86]= 4.430047519252572e-09;
 c[87]=0.0;
 c[88]=0.0;
 c[89]=0.0;
 c[90]=0.0;
 c[91]= 1.46580753570876;
 c[92]= 0.1086528834200811;
 c[93]= 0.008098507775955371;
 c[94]= 0.0006104479921504446;
 c[95]= 4.681922374915654e-05;
 c[96]= 3.678465622546537e-06;
 c[97]= 2.983629604350772e-07;
 c[98]= 2.521627254651016e-08;
 c[99]= 2.246444105727492e-09;
 c[100]=0.0;
 c[101]=0.0;
 c[102]=0.0;
 c[103]=0.0;
 c[104]=0.0;
 c[105]= 1.519126944936625;
 c[106]= 0.1048297184969734;
 c[107]= 0.007268633177563331;
 c[108]= 0.0005089061138323581;
 c[109]= 3.616638267560285e-05;
 c[110]= 2.623785168354005e-06;
 c[111]= 1.955653998265095e-07;
 c[112]= 1.508819816495316e-08;
 c[113]= 1.215841656708486e-09;
 c[114]=0.0;
 c[115]=0.0;
 c[116]=0.0;
 c[117]=0.0;
 c[118]=0.0;
 c[119]=0.0;
 c[120]= 1.570637328578554;
 c[121]= 0.1013842036086075;
 c[122]= 0.006571761828847014;
 c[123]= 0.0004296095103073734;
 c[124]= 2.845158486524923e-05;
 c[125]= 1.918205460301229e-06;
 c[126]= 1.323687523896326e-07;
 c[127]= 9.407037610856029e-09;
 c[128]=0.0;
 c[129]=0.0;
 c[130]=0.0;
 c[131]=0.0;
 c[132]=0.0;
 c[133]=0.0;
 c[134]=0.0;
 c[135]=0.0;
 c[136]= 1.620511203607144;
 c[137]= 0.09825792441130971;
 c[138]= 0.005979786850412427;
 c[139]= 0.000366644255972276;
 c[140]= 2.273831148908952e-05;
 c[141]= 1.432378986515563e-06;
 c[142]= 9.207680859947902e-08;
 c[143]= 6.071364964309775e-09;
 c[144]=0.0;
 c[145]=0.0;
 c[146]=0.0;
 c[147]=0.0;
 c[148]=0.0;
 c[149]=0.0;
 c[150]=0.0;
 c[151]=0.0;
 c[152]=0.0;
 c[153]= 1.668895294531136;
 c[154]= 0.09540439392102681;
 c[155]= 0.005471817261467132;
 c[156]= 0.000315915516886449;
 c[157]= 1.842456709998578e-05;
 c[158]= 1.089467491695421e-06;
 c[159]= 6.557823669848324e-08;
 c[160]= 4.036061465505948e-09;
 c[161]=0.0;
 c[162]=0.0;
 c[163]=0.0;
 c[164]=0.0;
 c[165]=0.0;
 c[166]=0.0;
 c[167]=0.0;
 c[168]=0.0;
 c[169]=0.0;
 c[170]=0.0;
 c[171]= 1.715915629394424;
 c[172]= 0.09278609064695012;
 c[173]= 0.005032032280811556;
 c[174]= 0.0002745198669795266;
 c[175]= 1.511182131758837e-05;
 c[176]= 8.421488772623757e-07;
 c[177]= 4.76772916527422e-08;
 c[178]= 2.7526497169943e-09;
 c[179]=0.0;
 c[180]=0.0;
 c[181]=0.0;
 c[182]=0.0;
 c[183]=0.0;
 c[184]=0.0;
 c[185]=0.0;
 c[186]=0.0;
 c[187]=0.0;
 c[188]=0.0;
 c[189]=0.0;
 c[190]= 1.761681409986482;
 c[191]= 0.09037234949584909;
 c[192]= 0.004648252090384827;
 c[193]= 0.0002403553935931609;
 c[194]= 1.252939101513388e-05;
 c[195]= 6.603568883778713e-07;
 c[196]= 3.529756041865882e-08;
 c[197]= 1.919934179336579e-09;
 c[198]=0.0;
 c[199]=0.0;
 c[200]=0.0;
 c[201]=0.0;
 c[202]=0.0;
 c[203]=0.0;
 c[204]=0.0;
 c[205]=0.0;
 c[206]=0.0;
 c[207]=0.0;
 c[208]=0.0;
 c[209]=0.0;
 c[210]= 1.806287998460892;
 c[211]= 0.08813782947320221;
 c[212]= 0.004310962154688459;
 c[213]= 0.0002118722309989988;
 c[214]= 1.048923844743225e-05;
 c[215]= 5.244619223716127e-07;
 c[216]= 2.65571617661055e-08;
 c[217]= 1.365953008665088e-09;
 c[218]=0.0;
 c[219]=0.0;
 c[220]=0.0;
 c[221]=0.0;
 c[222]=0.0;
 c[223]=0.0;
 c[224]=0.0;
 c[225]=0.0;
 c[226]=0.0;
 c[227]=0.0;
 c[228]=0.0;
 c[229]=0.0;
 c[230]=0.0;
 c[231]= 1.84981925508298;
 c[232]= 0.0860613804472887;
 c[233]= 0.004012632553544782;
 c[234]= 0.0001879087358370432;
 c[235]= 8.858102756970991e-06;
 c[236]= 4.213369811727295e-07;
 c[237]= 2.027158495830164e-08;
 c[238]=0.0;
 c[239]=0.0;
 c[240]=0.0;
 c[241]=0.0;
 c[242]=0.0;
 c[243]=0.0;
 c[244]=0.0;
 c[245]=0.0;
 c[246]=0.0;
 c[247]=0.0;
 c[248]=0.0;
 c[249]=0.0;
 c[250]=0.0;
 c[251]=0.0;
 c[252]=0.0;
 c[253]= 1.89234939151512;
 c[254]= 0.08412519161795824;
 c[255]= 0.003747233864656032;
 c[256]= 0.0001675813929792027;
 c[257]= 7.539843326915562e-06;
 c[258]= 3.420142387309604e-07;
 c[259]= 1.567619693034596e-08;
 c[260]=0.0;
 c[261]=0.0;
 c[262]=0.0;
 c[263]=0.0;
 c[264]=0.0;
 c[265]=0.0;
 c[266]=0.0;
 c[267]=0.0;
 c[268]=0.0;
 c[269]=0.0;
 c[270]=0.0;
 c[271]=0.0;
 c[272]=0.0;
 c[273]=0.0;
 c[274]=0.0;
 c[275]=0.0;
 c[276]= 1.933944456973762;
 c[277]= 0.08231414245617984;
 c[278]= 0.003509886827571061;
 c[279]= 0.0001502092895384877;
 c[280]= 6.463978631424566e-06;
 c[281]= 2.802490157049559e-07;
 c[282]= 1.226616618822204e-08;
 c[283]=0.0;
 c[284]=0.0;
 c[285]=0.0;
 c[286]=0.0;
 c[287]=0.0;
 c[288]=0.0;
 c[289]=0.0;
 c[290]=0.0;
 c[291]=0.0;
 c[292]=0.0;
 c[293]=0.0;
 c[294]=0.0;
 c[295]=0.0;
 c[296]=0.0;
 c[297]=0.0;
 c[298]=0.0;
 c[299]=0.0;
 c[300]= 1.974663542417147;
 c[301]= 0.0806153015433116;
 c[302]= 0.003296604831679497;
 c[303]= 0.0001352613346337005;
 c[304]= 5.578083425836789e-06;
 c[305]= 2.31617307381405e-07;
 c[306]= 9.701381442470045e-09;
 c[307]=0.0;
 c[308]=0.0;
 c[309]=0.0;
 c[310]=0.0;
 c[311]=0.0;
 c[312]=0.0;
 c[313]=0.0;
 c[314]=0.0;
 c[315]=0.0;
 c[316]=0.0;
 c[317]=0.0;
 c[318]=0.0;
 c[319]=0.0;
 c[320]=0.0;
 c[321]=0.0;
 c[322]=0.0;
 c[323]=0.0;
 c[324]=0.0;
 c[325]= 2.014559765517849;
 c[326]= 0.07901753504364936;
 c[327]= 0.00310410193677834;
 c[328]= 0.0001223187519200979;
 c[329]= 4.842645762398801e-06;
 c[330]= 1.929356253363671e-07;
 c[331]= 7.748481175203037e-09;
 c[332]=0.0;
 c[333]=0.0;
 c[334]=0.0;
 c[335]=0.0;
 c[336]=0.0;
 c[337]=0.0;
 c[338]=0.0;
 c[339]=0.0;
 c[340]=0.0;
 c[341]=0.0;
 c[342]=0.0;
 c[343]=0.0;
 c[344]=0.0;
 c[345]=0.0;
 c[346]=0.0;
 c[347]=0.0;
 c[348]=0.0;
 c[349]=0.0;
 c[350]=0.0;
 c[351]= 2.053681083307539;
 c[352]= 0.07751119753621069;
 c[353]= 0.002929647892908799;
 c[354]= 0.0001110480167994608;
 c[355]= 4.227525749644037e-06;
 c[356]= 1.618803274529695e-07;
 c[357]= 6.244669204738395e-09;
 c[358]=0.0;
 c[359]=0.0;
 c[360]=0.0;
 c[361]=0.0;
 c[362]=0.0;
 c[363]=0.0;
 c[364]=0.0;
 c[365]=0.0;
 c[366]=0.0;
 c[367]=0.0;
 c[368]=0.0;
 c[369]=0.0;
 c[370]=0.0;
 c[371]=0.0;
 c[372]=0.0;
 c[373]=0.0;
 c[374]=0.0;
 c[375]=0.0;
 c[376]=0.0;
 c[377]=0.0;
 c[378]= 2.092070967971001;
 c[379]= 0.07608788547576704;
 c[380]= 0.002770957355023711;
 c[381]= 0.0001011810566154225;
 c[382]= 3.709477511865982e-06;
 c[383]= 1.367331551655302e-07;
 c[384]= 5.074643349641621e-09;
 c[385]=0.0;
 c[386]=0.0;
 c[387]=0.0;
 c[388]=0.0;
 c[389]=0.0;
 c[390]=0.0;
 c[391]=0.0;
 c[392]=0.0;
 c[393]=0.0;
 c[394]=0.0;
 c[395]=0.0;
 c[396]=0.0;
 c[397]=0.0;
 c[398]=0.0;
 c[399]=0.0;
 c[400]=0.0;
 c[401]=0.0;
 c[402]=0.0;
 c[403]=0.0;
 c[404]=0.0;
 c[405]=0.0;
 c[406]= 2.129768972944957;
 c[407]= 0.07474023881535388;
 c[408]= 0.002626104305793813;
 c[409]= 9.250057893259113e-05;
 c[410]= 3.270389331345833e-06;
 c[411]= 1.162082247007796e-07;
 c[412]= 4.155597631240415e-09;
 c[413]=0.0;
 c[414]=0.0;
 c[415]=0.0;
 c[416]=0.0;
 c[417]=0.0;
 c[418]=0.0;
 c[419]=0.0;
 c[420]=0.0;
 c[421]=0.0;
 c[422]=0.0;
 c[423]=0.0;
 c[424]=0.0;
 c[425]=0.0;
 c[426]=0.0;
 c[427]=0.0;
 c[428]=0.0;
 c[429]=0.0;
 c[430]=0.0;
 c[431]=0.0;
 c[432]=0.0;
 c[433]=0.0;
 c[434]=0.0;
 c[435]= 2.166811210329805;
 c[436]= 0.07346178004805379;
 c[437]= 0.002493455287686542;
 c[438]= 8.482907154550921e-05;
 c[439]= 2.896016752274726e-06;
 c[440]= 9.933255511282382e-08;
 c[441]= 3.4272987602418e-09;
 c[442]=0.0;
 c[443]=0.0;
 c[444]=0.0;
 c[445]=0.0;
 c[446]=0.0;
 c[447]=0.0;
 c[448]=0.0;
 c[449]=0.0;
 c[450]=0.0;
 c[451]=0.0;
 c[452]=0.0;
 c[453]=0.0;
c[454]=0.0;
 c[455]=0.0;
 c[456]=0.0;
 c[457]=0.0;
 c[458]=0.0;
 c[459]=0.0;
 c[460]=0.0;
 c[461]=0.0;
 c[462]=0.0;
 c[463]=0.0;
 c[464]=0.0;
 c[465]= 2.203230756026887;
 c[466]= 0.07224678259981218;
 c[467]= 0.002371616827193302;
 c[468]= 7.802046556234715e-05;
 c[469]= 2.575059075948476e-06;
 c[470]= 8.536237715559136e-08;
 c[471]= 2.845412571853045e-09;
 c[472]=0.0;
 c[473]=0.0;
 c[474]=0.0;
 c[475]=0.0;
 c[476]=0.0;
 c[477]=0.0;
 c[478]=0.0;
 c[479]=0.0;
 c[480]=0.0;
 c[481]=0.0;
 c[482]=0.0;
 c[483]=0.0;
 c[484]=0.0;
 c[485]=0.0;
 c[486]=0.0;
 c[487]=0.0;
 c[488]=0.0;
 c[489]=0.0;
 c[490]=0.0;
 c[491]=0.0;
 c[492]=0.0;
 c[493]=0.0;
 c[494]=0.0;
 c[495]=0.0;
 c[496]= 2.239057995540692;
 c[497]= 0.07109016244861498;
 c[498]= 0.002259393678604874;
 c[499]= 7.195375314183696e-05;
 c[500]= 2.298478332305522e-06;
 c[501]= 7.372372688239529e-08;
 c[502]= 2.376948353998878e-09;
 c[503]=0.0;
 c[504]=0.0;
 c[505]=0.0;
 c[506]=0.0;
 c[507]=0.0;
 c[508]=0.0;
 c[509]=0.0;
 c[510]=0.0;
 c[511]=0.0;
 c[512]=0.0;
 c[513]=0.0;
 c[514]=0.0;
 c[515]=0.0;
 c[516]=0.0;
 c[517]=0.0;
 c[518]=0.0;
 c[519]=0.0;
 c[520]=0.0;
 c[521]=0.0;
 c[522]=0.0;
 c[523]=0.0;
 c[524]=0.0;
 c[525]=0.0;
 c[526]=0.0;
 c[527]=0.0;
 c[528]= 2.274320920733615;
 c[529]= 0.06998738827464737;
 c[530]= 0.002155755395657693;
 c[531]= 6.652805584976738e-05;
 c[532]= 2.058991638214058e-06;
 c[533]= 6.396975762177483e-08;
 c[534]= 1.997105578629141e-09;
 c[535]=0.0;
 c[536]=0.0;
 c[537]=0.0;
 c[538]=0.0;
 c[539]=0.0;
 c[540]=0.0;
 c[541]=0.0;
 c[542]=0.0;
 c[543]=0.0;
 c[544]=0.0;
 c[545]=0.0;
 c[546]=0.0;
 c[547]=0.0;
 c[548]=0.0;
 c[549]=0.0;
 c[550]=0.0;
 c[551]=0.0;
 c[552]=0.0;
 c[553]=0.0;
 c[554]=0.0;
 c[555]=0.0;
 c[556]=0.0;
 c[557]=0.0;
 c[558]=0.0;
 c[559]=0.0;
 c[560]=0.0;
 c[561]= 2.309045385777095;
 c[562]= 0.06893440650860676;
 c[563]= 0.002059809370664345;
 c[564]= 6.165878068929182e-05;
 c[565]= 1.850688996628934e-06;
 c[566]= 5.574971423464406e-08;
 c[567]= 1.687063099661222e-09;
 c[568]=0.0;
 c[569]=0.0;
 c[570]=0.0;
 c[571]=0.0;
 c[572]=0.0;
 c[573]=0.0;
 c[574]=0.0;
 c[575]=0.0;
 c[576]=0.0;
 c[577]=0.0;
 c[578]=0.0;
 c[579]=0.0;
 c[580]=0.0;
 c[581]=0.0;
 c[582]=0.0;
 c[583]=0.0;
 c[584]=0.0;
 c[585]=0.0;
 c[586]=0.0;
 c[587]=0.0;
 c[588]=0.0;
 c[589]=0.0;
 c[590]=0.0;
 c[591]=0.0;
 c[592]=0.0;
 c[593]=0.0;
 c[594]=0.0;
 c[595]= 2.343255328953802;
 c[596]= 0.0679275784432832;
 c[597]= 0.001970778938358922;
 c[598]= 5.727459951756891e-05;
 c[599]= 1.668742842362807e-06;
 c[600]= 4.878614306851687e-08;
 c[601]= 1.43241048209851e-09;
 c[602]=0.0;
 c[603]=0.0;
 c[604]=0.0;
 c[605]=0.0;
 c[606]=0.0;
 c[607]=0.0;
 c[608]=0.0;
 c[609]=0.0;
 c[610]=0.0;
 c[611]=0.0;
 c[612]=0.0;
 c[613]=0.0;
 c[614]=0.0;
 c[615]=0.0;
 c[616]=0.0;
 c[617]=0.0;
 c[618]=0.0;
 c[619]=0.0;
 c[620]=0.0;
 c[621]=0.0;
 c[622]=0.0;
 c[623]=0.0;
 c[624]=0.0;
 c[625]=0.0;
 c[626]=0.0;
 c[627]=0.0;
 c[628]=0.0;
 c[629]=0.0;
 c[630]= 2.376972965719696;
 c[631]= 0.06696362717842202;
 c[632]= 0.001887985476978138;
 c[633]= 5.331505738460513e-05;
 c[634]= 1.509185376267241e-06;
 c[635]= 4.285798472617944e-08;
 c[636]= 1.222022465559807e-09;
 c[637]=0.0;
 c[638]=0.0;
 c[639]=0.0;
 c[640]=0.0;
 c[641]=0.0;
 c[642]=0.0;
 c[643]=0.0;
 c[644]=0.0;
 c[645]=0.0;
 c[646]=0.0;
 c[647]=0.0;
 c[648]=0.0;
 c[649]=0.0;
 c[650]=0.0;
 c[651]=0.0;
 c[652]=0.0;
 c[653]=0.0;
 c[654]=0.0;
 c[655]=0.0;
 c[656]=0.0;
 c[657]=0.0;
 c[658]=0.0;
 c[659]=0.0;
 c[660]=0.0;
 c[661]=0.0;
 c[662]=0.0;
 c[663]=0.0;
 c[664]=0.0;
 c[665]=0.0;
 c[666]= 2.410218957450584;
 c[667]= 0.06603959263150834;
 c[668]= 0.00181083368723047;
 c[669]= 4.97286653043065e-05;
 c[670]= 1.368736464703448e-06;
 c[671]= 3.778791414787301e-08;
 c[672]= 1.047242907767924e-09;
 c[673]=0.0;
 c[674]=0.0;
 c[675]=0.0;
 c[676]=0.0;
 c[677]=0.0;
 c[678]=0.0;
 c[679]=0.0;
 c[680]=0.0;
 c[681]=0.0;
 c[682]=0.0;
 c[683]=0.0;
 c[684]=0.0;
 c[685]=0.0;
 c[686]=0.0;
 c[687]=0.0;
 c[688]=0.0;
 c[689]=0.0;
 c[690]=0.0;
 c[691]=0.0;
 c[692]=0.0;
 c[693]=0.0;
 c[694]=0.0;
 c[695]=0.0;
 c[696]=0.0;
 c[697]=0.0;
 c[698]=0.0;
 c[699]=0.0;
 c[700]=0.0;
 c[701]=0.0;
 c[702]=0.0;
 c[703]= 2.4430125595146;
 c[704]= 0.06515279320386852;
 c[705]= 0.001738799415163349;
 c[706]= 4.647136911331539e-05;
 c[707]= 1.244669595191882e-06;
 c[708]= 3.34327780809931e-08;
 c[709]=0.0;
 c[710]=0.0;
 c[711]=0.0;
 c[712]=0.0;
 c[713]=0.0;
 c[714]=0.0;
 c[715]=0.0;
 c[716]=0.0;
 c[717]=0.0;
 c[718]=0.0;
 c[719]=0.0;
 c[720]=0.0;
 c[721]=0.0;
 c[722]=0.0;
 c[723]=0.0;
 c[724]=0.0;
 c[725]=0.0;
 c[726]=0.0;
 c[727]=0.0;
 c[728]=0.0;
 c[729]=0.0;
 c[730]=0.0;
 c[731]=0.0;
 c[732]=0.0;
 c[733]=0.0;
 c[734]=0.0;
 c[735]=0.0;
 c[736]=0.0;
 c[737]=0.0;
 c[738]=0.0;
 c[739]=0.0;
 c[740]=0.0;
 c[741]= 2.475371751684577;
 c[742]= 0.06430079296874097;
 c[743]= 0.001671419524626688;
 c[744]= 4.35053124758359e-05;
 c[745]= 1.134706714967917e-06;
 c[746]= 2.967631270159956e-08;
 c[747]=0.0;
 c[748]=0.0;
 c[749]=0.0;
 c[750]=0.0;
 c[751]=0.0;
 c[752]=0.0;
 c[753]=0.0;
 c[754]=0.0;
 c[755]=0.0;
 c[756]=0.0;
 c[757]=0.0;
 c[758]=0.0;
 c[759]=0.0;
 c[760]=0.0;
 c[761]=0.0;
 c[762]=0.0;
 c[763]=0.0;
 c[764]=0.0;
 c[765]=0.0;
 c[766]=0.0;
 c[767]=0.0;
 c[768]=0.0;
 c[769]=0.0;
 c[770]=0.0;
 c[771]=0.0;
 c[772]=0.0;
 c[773]=0.0;
 c[774]=0.0;
 c[775]=0.0;
 c[776]=0.0;
 c[777]=0.0;
 c[778]=0.0;
 c[779]=0.0;
 c[780]= 2.507313353398387;
 c[781]= 0.06348137346502772;
 c[782]= 0.001608283431176744;
 c[783]= 4.079783155811154e-05;
 c[784]= 1.036935164213738e-06;
 c[785]= 2.642355470722224e-08;
 c[786]=0.0;
 c[787]=0.0;
 c[788]=0.0;
 c[789]=0.0;
 c[790]=0.0;
 c[791]=0.0;
 c[792]=0.0;
 c[793]=0.0;
 c[794]=0.0;
 c[795]=0.0;
 c[796]=0.0;
 c[797]=0.0;
 c[798]=0.0;
 c[799]=0.0;
 c[800]=0.0;
 c[801]=0.0;
 c[802]=0.0;
 c[803]=0.0;
 c[804]=0.0;
 c[805]=0.0;
 c[806]=0.0;
 c[807]=0.0;
 c[808]=0.0;
 c[809]=0.0;
 c[810]=0.0;
 c[811]=0.0;
 c[812]=0.0;
 c[813]=0.0;
 c[814]=0.0;
 c[815]=0.0;
 c[816]=0.0;
 c[817]=0.0;
 c[818]=0.0;
 c[819]=0.0;
 c[820]= 2.538853125964903;
 c[821]= 0.06269250935154659;
 c[822]= 0.001549025990553454;
 c[823]= 3.832063337304655e-05;
 c[824]= 9.497416376052678e-07;
 c[825]= 2.359652069719277e-08;
 c[826]=0.0;
 c[827]=0.0;
 c[828]=0.0;
 c[829]=0.0;
 c[830]=0.0;
 c[831]=0.0;
 c[832]=0.0;
 c[833]=0.0;
 c[834]=0.0;
 c[835]=0.0;
 c[836]=0.0;
 c[837]=0.0;
 c[838]=0.0;
 c[839]=0.0;
 c[840]=0.0;
 c[841]=0.0;
 c[842]=0.0;
 c[843]=0.0;
 c[844]=0.0;
 c[845]=0.0;
 c[846]=0.0;
 c[847]=0.0;
 c[848]=0.0;
 c[849]=0.0;
 c[850]=0.0;
 c[851]=0.0;
 c[852]=0.0;
 c[853]=0.0;
 c[854]=0.0;
 c[855]=0.0;
 c[856]=0.0;
 c[857]=0.0;
 c[858]=0.0;
 c[859]=0.0;
 c[860]=0.0;
 c[861]= 2.570005863478459;
 c[862]= 0.06193234731236989;
 c[863]= 0.001493321497577769;
 c[864]= 3.604912065120161e-05;
 c[865]= 8.71759362326571e-07;
 c[866]= 2.113084392782858e-08;
 c[867]=0.0;
 c[868]=0.0;
 c[869]=0.0;
 c[870]=0.0;
 c[871]=0.0;
 c[872]=0.0;
 c[873]=0.0;
 c[874]=0.0;
 c[875]=0.0;
 c[876]=0.0;
 c[877]=0.0;
 c[878]=0.0;
 c[879]=0.0;
 c[880]=0.0;
 c[881]=0.0;
 c[882]=0.0;
 c[883]=0.0;
 c[884]=0.0;
 c[885]=0.0;
 c[886]=0.0;
 c[887]=0.0;
 c[888]=0.0;
 c[889]=0.0;
 c[890]=0.0;
 c[891]=0.0;
 c[892]=0.0;
 c[893]=0.0;
 c[894]=0.0;
 c[895]=0.0;
 c[896]=0.0;
 c[897]=0.0;
 c[898]=0.0;
 c[899]=0.0;
 c[900]=0.0;
 c[901]=0.0;
 c[902]=0.0;
 c[903]= 2.60078547393005;
 c[904]= 0.06119918771222799;
 c[905]= 0.001440878600036247;
 c[906]= 3.396183429840699e-05;
 c[907]= 8.018256026422763e-07;
 c[908]= 1.897313915903101e-08;
 c[909]=0.0;
 c[910]=0.0;
 c[911]=0.0;
 c[912]=0.0;
 c[913]=0.0;
 c[914]=0.0;
 c[915]=0.0;
 c[916]=0.0;
 c[917]=0.0;
 c[918]=0.0;
 c[919]=0.0;
 c[920]=0.0;
 c[921]=0.0;
 c[922]=0.0;
 c[923]=0.0;
 c[924]=0.0;
 c[925]=0.0;
 c[926]=0.0;
 c[927]=0.0;
 c[928]=0.0;
 c[929]=0.0;
 c[930]=0.0;
 c[931]=0.0;
 c[932]=0.0;
 c[933]=0.0;
 c[934]=0.0;
 c[935]=0.0;
 c[936]=0.0;
 c[937]=0.0;
 c[938]=0.0;
 c[939]=0.0;
 c[940]=0.0;
 c[941]=0.0;
 c[942]=0.0;
 c[943]=0.0;
 c[944]=0.0;
 c[945]=0.0;
 c[946]= 2.631205051777122;
 c[947]= 0.06049146858800099;
 c[948]= 0.001391435970220645;
 c[949]= 3.203999074612218e-05;
 c[950]= 7.389472842063599e-07;
 c[951]= 1.707892514789033e-08;
 c[952]=0.0;
 c[953]=0.0;
 c[954]=0.0;
 c[955]=0.0;
 c[956]=0.0;
 c[957]=0.0;
 c[958]=0.0;
 c[959]=0.0;
 c[960]=0.0;
 c[961]=0.0;
 c[962]=0.0;
 c[963]=0.0;
 c[964]=0.0;
 c[965]=0.0;
 c[966]=0.0;
 c[967]=0.0;
 c[968]=0.0;
 c[969]=0.0;
 c[970]=0.0;
 c[971]=0.0;
 c[972]=0.0;
 c[973]=0.0;
 c[974]=0.0;
 c[975]=0.0;
 c[976]=0.0;
 c[977]=0.0;
 c[978]=0.0;
 c[979]=0.0;
 c[980]=0.0;
 c[981]=0.0;
 c[982]=0.0;
 c[983]=0.0;
 c[984]=0.0;
 c[985]=0.0;
 c[986]=0.0;
 c[987]=0.0;
 c[988]=0.0;
 c[989]=0.0;
 c[990]= 2.661276943046203;
 c[991]= 0.05980775163261159;
 c[992]= 0.001344758606772777;
 c[993]= 3.026709628913576e-05;
 c[994]= 6.82273041336726e-07;
 c[995]= 1.541097711967333e-08;
 c[996]=0.0;
 c[997]=0.0;
 c[998]=0.0;
 c[999]=0.0;
 c[1000]=0.0;
 c[1001]=0.0;
 c[1002]=0.0;
 c[1003]=0.0;
 c[1004]=0.0;
 c[1005]=0.0;
 c[1006]=0.0;
 c[1007]=0.0;
 c[1008]=0.0;
 c[1009]=0.0;
 c[1010]=0.0;
 c[1011]=0.0;
 c[1012]=0.0;
 c[1013]=0.0;
 c[1014]=0.0;
 c[1015]=0.0;
 c[1016]=0.0;
 c[1017]=0.0;
 c[1018]=0.0;
 c[1019]=0.0;
 c[1020]=0.0;
 c[1021]=0.0;
 c[1022]=0.0;
 c[1023]=0.0;
 c[1024]=0.0;
 c[1025]=0.0;
 c[1026]=0.0;
 c[1027]=0.0;
 c[1028]=0.0;
 c[1029]=0.0;
 c[1030]=0.0;
 c[1031]=0.0;
 c[1032]=0.0;
 c[1033]=0.0;
 c[1034]=0.0;
 c[1035]= 2.691012803886529;
 c[1036]= 0.05914670988469412;
 c[1037]= 0.0013006346632196;
 c[1038]= 2.862862420075548e-05;
 c[1039]= 6.310703741403411e-07;
 c[1040]= 1.393801289538844e-08;
 c[1041]=0.0;
 c[1042]=0.0;
 c[1043]=0.0;
 c[1044]=0.0;
 c[1045]=0.0;
 c[1046]=0.0;
 c[1047]=0.0;
 c[1048]=0.0;
 c[1049]=0.0;
 c[1050]=0.0;
 c[1051]=0.0;
 c[1052]=0.0;
 c[1053]=0.0;
 c[1054]=0.0;
 c[1055]=0.0;
 c[1056]=0.0;
 c[1057]=0.0;
 c[1058]=0.0;
 c[1059]=0.0;
 c[1060]=0.0;
 c[1061]=0.0;
 c[1062]=0.0;
 c[1063]=0.0;
 c[1064]=0.0;
 c[1065]=0.0;
 c[1066]=0.0;
 c[1067]=0.0;
 c[1068]=0.0;
 c[1069]=0.0;
 c[1070]=0.0;
 c[1071]=0.0;
 c[1072]=0.0;
 c[1073]=0.0;
 c[1074]=0.0;
 c[1075]=0.0;
 c[1076]=0.0;
 c[1077]=0.0;
 c[1078]=0.0;
 c[1079]=0.0;
 c[1080]=0.0;
 c[1081]= 2.720423653362309;
 c[1082]= 0.05850711688397001;
 c[1083]= 0.001258872718479037;
 c[1084]= 2.711174328577707e-05;
 c[1085]= 5.847068929770086e-07;
 c[1086]= 1.263363950714379e-08;
 c[1087]=0.0;
 c[1088]=0.0;
 c[1089]=0.0;
 c[1090]=0.0;
 c[1091]=0.0;
 c[1092]=0.0;
 c[1093]=0.0;
 c[1094]=0.0;
 c[1095]=0.0;
 c[1096]=0.0;
 c[1097]=0.0;
 c[1098]=0.0;
 c[1099]=0.0;
 c[1100]=0.0;
 c[1101]=0.0;
 c[1102]=0.0;
 c[1103]=0.0;
 c[1104]=0.0;
 c[1105]=0.0;
 c[1106]=0.0;
 c[1107]=0.0;
 c[1108]=0.0;
 c[1109]=0.0;
 c[1110]=0.0;
 c[1111]=0.0;
 c[1112]=0.0;
 c[1113]=0.0;
 c[1114]=0.0;
 c[1115]=0.0;
 c[1116]=0.0;
 c[1117]=0.0;
 c[1118]=0.0;
 c[1119]=0.0;
 c[1120]=0.0;
 c[1121]=0.0;
 c[1122]=0.0;
 c[1123]=0.0;
 c[1124]=0.0;
 c[1125]=0.0;
 c[1126]=0.0;
 c[1127]=0.0;
 c[1128]= 2.749519921161698;
 c[1129]= 0.05788783709042469;
 c[1130]= 0.001219299419741175;
 c[1131]= 2.570508877402524e-05;
 c[1132]= 5.426348493370343e-07;
 c[1133]= 1.147550435625091e-08;
 c[1134]=0.0;
 c[1135]=0.0;
 c[1136]=0.0;
 c[1137]=0.0;
 c[1138]=0.0;
 c[1139]=0.0;
 c[1140]=0.0;
 c[1141]=0.0;
 c[1142]=0.0;
 c[1143]=0.0;
 c[1144]=0.0;
 c[1145]=0.0;
 c[1146]=0.0;
 c[1147]=0.0;
 c[1148]=0.0;
 c[1149]=0.0;
 c[1150]=0.0;
 c[1151]=0.0;
 c[1152]=0.0;
 c[1153]=0.0;
 c[1154]=0.0;
 c[1155]=0.0;
 c[1156]=0.0;
 c[1157]=0.0;
 c[1158]=0.0;
 c[1159]=0.0;
 c[1160]=0.0;
 c[1161]=0.0;
 c[1162]=0.0;
 c[1163]=0.0;
 c[1164]=0.0;
 c[1165]=0.0;
 c[1166]=0.0;
 c[1167]=0.0;
 c[1168]=0.0;
 c[1169]=0.0;
 c[1170]=0.0;
 c[1171]=0.0;
 c[1172]=0.0;
 c[1173]=0.0;
 c[1174]=0.0;
 c[1175]=0.0;
 c[1176]= 2.778311490808207;
 c[1177]= 0.05728781739681247;
 c[1178]= 0.00118175744029733;
 c[1179]= 2.43985682194388e-05;
 c[1180]= 5.043783222424648e-07;
 c[1181]= 1.044460787186219e-08;
 c[1182]=0.0;
 c[1183]=0.0;
 c[1184]=0.0;
 c[1185]=0.0;
 c[1186]=0.0;
 c[1187]=0.0;
 c[1188]=0.0;
 c[1189]=0.0;
 c[1190]=0.0;
 c[1191]=0.0;
 c[1192]=0.0;
 c[1193]=0.0;
 c[1194]=0.0;
 c[1195]=0.0;
 c[1196]=0.0;
 c[1197]=0.0;
 c[1198]=0.0;
 c[1199]=0.0;
 c[1200]=0.0;
 c[1201]=0.0;
 c[1202]=0.0;
 c[1203]=0.0;
 c[1204]=0.0;
 c[1205]=0.0;
 c[1206]=0.0;
 c[1207]=0.0;
 c[1208]=0.0;
 c[1209]=0.0;
 c[1210]=0.0;
 c[1211]=0.0;
 c[1212]=0.0;
 c[1213]=0.0;
 c[1214]=0.0;
 c[1215]=0.0;
 c[1216]=0.0;
 c[1217]=0.0;
 c[1218]=0.0;
 c[1219]=0.0;
 c[1220]=0.0;
 c[1221]=0.0;
 c[1222]=0.0;
 c[1223]=0.0;
 c[1224]=0.0;
 c[1225]= 2.806807738882166;
 c[1226]= 0.05670607959001315;
 c[1227]= 0.00114610370472699;
 c[1228]= 2.318319646198824e-05;
 c[1229]= 4.695225605470426e-07;
 c[1230]= 9.524744358118536e-09;
 c[1231]=0.0;
 c[1232]=0.0;
 c[1233]=0.0;
 c[1234]=0.0;
 c[1235]=0.0;
 c[1236]=0.0;
 c[1237]=0.0;
 c[1238]=0.0;
 c[1239]=0.0;
 c[1240]=0.0;
 c[1241]=0.0;
 c[1242]=0.0;
 c[1243]=0.0;
 c[1244]=0.0;
 c[1245]=0.0;
 c[1246]=0.0;
 c[1247]=0.0;
 c[1248]=0.0;
 c[1249]=0.0;
 c[1250]=0.0;
 c[1251]=0.0;
 c[1252]=0.0;
 c[1253]=0.0;
 c[1254]=0.0;
 c[1255]=0.0;
 c[1256]=0.0;
 c[1257]=0.0;
 c[1258]=0.0;
 c[1259]=0.0;
 c[1260]=0.0;
 c[1261]=0.0;
 c[1262]=0.0;
 c[1263]=0.0;
 c[1264]=0.0;
 c[1265]=0.0;
 c[1266]=0.0;
 c[1267]=0.0;
 c[1268]=0.0;
 c[1269]=0.0;
 c[1270]=0.0;
 c[1271]=0.0;
 c[1272]=0.0;
 c[1273]=0.0;
 c[1274]=0.0;
 c[1275]= 2.835017570693472;
 c[1276]= 0.05614171363835682;
 c[1277]= 0.00111220784184347;
 c[1278]= 2.205095481555296e-05;
 c[1279]= 4.377050834318466e-07;
 c[1280]= 8.702045102005835e-09;
 c[1281]=0.0;
 c[1282]=0.0;
 c[1283]=0.0;
 c[1284]=0.0;
 c[1285]=0.0;
 c[1286]=0.0;
 c[1287]=0.0;
 c[1288]=0.0;
 c[1289]=0.0;
 c[1290]=0.0;
 c[1291]=0.0;
 c[1292]=0.0;
 c[1293]=0.0;
 c[1294]=0.0;
 c[1295]=0.0;
 c[1296]=0.0;
 c[1297]=0.0;
 c[1298]=0.0;
 c[1299]=0.0;
 c[1300]=0.0;
 c[1301]=0.0;
 c[1302]=0.0;
 c[1303]=0.0;
 c[1304]=0.0;
 c[1305]=0.0;
 c[1306]=0.0;
 c[1307]=0.0;
 c[1308]=0.0;
 c[1309]=0.0;
 c[1310]=0.0;
 c[1311]=0.0;
 c[1312]=0.0;
 c[1313]=0.0;
 c[1314]=0.0;
 c[1315]=0.0;
 c[1316]=0.0;
 c[1317]=0.0;
 c[1318]=0.0;
 c[1319]=0.0;
 c[1320]=0.0;
 c[1321]=0.0;
 c[1322]=0.0;
 c[1323]=0.0;
 c[1324]=0.0;
 c[1325]=0.0;
  return c;
}
double* getws(){ // OK
 double* c = (double* ) malloc(sd*100);
c[0] = 7.34634490505672E-4;
c[1] = 0.001709392653518105;
c[2] = 0.002683925371553482;
c[3] = 0.003655961201326375;
c[4] = 0.00462445006342212;
c[5] = 0.00558842800386552;
c[6] = 0.00654694845084532;
c[7] = 0.007499073255464712;
c[8] = 0.008443871469668971;
c[9] = 0.00938041965369446;
c[10] = 0.01030780257486897;
c[11] = 0.01122511402318598;
c[12] = 0.012131457662979497;
c[13] = 0.0130259478929715423;
c[14] = 0.0139077107037187727;
c[15] = 0.014775884527441302;
c[16] = 0.015629621077546003;
c[17] = 0.01646808617614521;
c[18] = 0.017290460568323582;
c[19] = 0.018095940722128117;
c[20] = 0.018883739613374905;
c[21] = 0.019653087494435306;
c[22] = 0.020403232646209433;
c[23] = 0.021133442112527642;
c[24] = 0.02184300241624739;
c[25] = 0.022531220256336273;
c[26] = 0.023197423185254122;
c[27] = 0.023840960265968206;
c[28] = 0.02446120270795705;
c[29] = 0.02505754448157959;
c[30] = 0.02562940291020812;
c[31] = 0.02617621923954568;
c[32] = 0.026697459183570963;
c[33] = 0.02719261344657688;
c[34] = 0.027661198220792388;
c[35] = 0.028102755659101173;
c[36] = 0.028516854322395098;
c[37] = 0.028903089601125203;
c[38] = 0.029261084110638277;
c[39] = 0.02959048805991264;
c[40] = 0.029890979593332831;
c[41] = 0.03016226510516914;
c[42] = 0.03040407952645482;
c[43] = 0.03061618658398045;
c[44] = 0.03079837903115259;
c[45] = 0.030950478850490988;
c[46] = 0.031072337427566517;
c[47] = 0.031163835696209907;
c[48] = 0.03122488425484936;
c[49] = 0.03125542345386336;
c[50] = 0.031255423453863357;
c[51] = 0.03122488425484936;
c[52] = 0.0311638356962099068;
c[53] = 0.031072337427566517;
c[54] = 0.030950478850490988;
c[55] = 0.03079837903115259;
c[56] = 0.030616186583980449;
c[57] = 0.03040407952645482;
c[58] = 0.0301622651051691449;
c[59] = 0.02989097959333283;
c[60] = 0.029590488059912643;
c[61] = 0.029261084110638277;
c[62] = 0.028903089601125203;
c[63] = 0.0285168543223951;
c[64] = 0.02810275565910117;
c[65] = 0.02766119822079239;
c[66] = 0.02719261344657688;
c[67] = 0.02669745918357096;
c[68] = 0.02617621923954568;
c[69] = 0.025629402910208116;
c[70] = 0.02505754448157959;
c[71] = 0.024461202707957053;
c[72] = 0.02384096026596821;
c[73] = 0.023197423185254122;
c[74] = 0.0225312202563362727;
c[75] = 0.021843002416247386;
c[76] = 0.02113344211252764;
c[77] = 0.020403232646209433;
c[78] = 0.019653087494435306;
c[79] = 0.0188837396133749046;
c[80] = 0.018095940722128117;
c[81] = 0.017290460568323582;
c[82] = 0.016468086176145213;
c[83] = 0.015629621077546003;
c[84] = 0.0147758845274413;
c[85] = 0.013907710703718773;
c[86] = 0.01302594789297154;
c[87] = 0.0121314576629795;
c[88] = 0.01122511402318598;
c[89] = 0.01030780257486897;
c[90] = 0.00938041965369446;
c[91] = 0.008443871469668971;
c[92] = 0.007499073255464712;
c[93] = 0.00654694845084532;
c[94] = 0.005588428003865515;
c[95] = 0.00462445006342212;
c[96] = 0.003655961201326375;
c[97] = 0.002683925371553482;
c[98] = 0.001709392653518105;
c[99] = 7.3463449050567E-4;
return c;
}

inline double factorY(int l, int m, double* c)
{
    return c[(l*(l+1))/2 + m];//l+1
}
inline double* getoOr(double* r, int rsize)
{
    double* oOr = (double*) malloc(sd*rsize);
    for (int w = 0; w < rsize; w++) {
        oOr[w] = 1/r[w];
    }
    return oOr;
}
inline double* getrw2(double* r, int rsize)
{
    double* rw2 = (double*) malloc(sd*rsize);
    for(int w = 0; w < rsize; w++){
        rw2[w] = r[w]*r[w];
    }
    return rw2;
}
inline void expMs(double* rExpDiff, double eta, double* r, double* ri, int isize, int rsize)
{
    double rDiff;
    for (int i = 0; i < isize; i++) {
        for (int w = 0; w < rsize; w++) {
            rDiff = r[w] - ri[i];
            if (rDiff > 5.0 ) {
                rExpDiff[rsize*i + w] = 0.0;
            } else {
                rExpDiff[rsize*i + w] = exp(-eta*rDiff*rDiff);
            }
        }
    }
}
inline void expPs(double* rExpSum, double eta, double* r, double* ri, int isize, int rsize)
{
    double rSum;
    for (int i = 0; i < isize; i++) {
        for (int w = 0; w < rsize; w++) {
            rSum = r[w] + ri[i];
            if (rSum > 5.0 ) {
                rExpSum[rsize*i + w] = 0.0;
            } else {
                rExpSum[rsize*i + w] = exp(-eta*rSum*rSum);
            }
        }
    }
}
pair<int, int> getDeltas(double* dx, double* dy, double* dz, double* ri, double* rw, double rCut, double* oOri, double* oO4arri, double* minExp, double* pluExp, double eta, const py::array_t<double> &positions, const double ix, const double iy, const double iz, const vector<int> &indices, int rsize, int Ihpos, int Itype)
{
    int iNeighbour = 0;
    int iCenter = 0;
    double ri2;
    double oOa = 1/eta;
    double Xi; double Yi; double Zi;
    int nNeighbours = indices.size();
    double* oO4ari = (double*) malloc(sd*nNeighbours);

    auto pos = positions.unchecked<2>();
    for (const int &i : indices) {
        Xi = pos(i, 0) - ix;
        Yi = pos(i, 1) - iy;
        Zi = pos(i, 2) - iz;
        ri2 = Xi*Xi + Yi*Yi + Zi*Zi;

        // When an atom is very close to the center (=approximately on top of
        // it), we do not add it to the calculations, as the numerical
        // integration cannot handle these cases. Instead, we gather the number
        // of such centered atoms and report them back for later correction.
        if (ri2<=1e-12) {
            iCenter++;
        } else {
            ri[iNeighbour] = sqrt(ri2);
            dx[iNeighbour] = Xi;
            dy[iNeighbour] = Yi;
            dz[iNeighbour] = Zi;
            oOri[iNeighbour] = 1/ri[iNeighbour];
            oO4ari[iNeighbour] = 0.25*oOa*oOri[iNeighbour];
            iNeighbour++;
        }
    }

    // If there is at least one atom at the center, we add a zero element to
    // the end of ris so that the weights can be calculated. This way they do
    // not interfere with the calculations for non-centered atoms.
    if (iCenter > 0) {
        ri[iNeighbour] = 0;
    }

    double* oOr = getoOr(rw, rsize);
    for (int i = 0; i < iNeighbour; i++) {
        for (int w = 0; w < rsize; w++) {
            oO4arri[rsize*i + w] = oO4ari[i]*oOr[w];
        }
    }
    expMs(minExp, eta, rw, ri, iNeighbour, rsize);
    expPs(pluExp, eta, rw, ri, iNeighbour, rsize);

    free(oO4ari);
    return make_pair(iNeighbour, iCenter);
}
double* getFlir(double* oO4arri,double* ri, double* minExp, double* pluExp, int icount, int rsize, int lMax)
{
    double* Flir = (double*) malloc(sd*(lMax+1)*icount*rsize);
    //l=0
    for (int i = 0; i < icount; i++) {
        for (int w = 0; w < rsize; w++) {
            Flir[rsize*i + w] = oO4arri[rsize*i + w]*(minExp[rsize*i + w] - pluExp[rsize*i + w]);
        }
    }
    //l=1
    if (lMax>0) {
        for (int i = 0; i < icount; i++) {
            for (int w = 0; w < rsize; w++) {
                Flir[rsize*icount + rsize*i + w] = oO4arri[rsize*i + w]*(minExp[rsize*i + w] + pluExp[rsize*i + w] - 2*Flir[rsize*i + w]);
            }
        }
    }
    //l>1
    if (lMax>1) {
        for (int l = 2; l < lMax+1; l++){
            for (int i = 0; i < icount; i++){
                for (int w = 0; w < rsize; w++){
                    Flir[l*rsize*icount+rsize*i+w] = Flir[(l-2)*rsize*icount+rsize*i+w] - oO4arri[rsize*i+w]*(4*l-2)*Flir[(l-1)*rsize*icount+rsize*i+w] ;
                    // Very Important!!!
                    if (Flir[l*rsize*icount+rsize*i+w] < 0) {
                        Flir[l*rsize*icount+rsize*i+w] = 0.0;
                    }
                }
            }
        }
    }

    return Flir;
}
double legendre_poly(int l, int m, double x)
{
    double fact,pll,pmm,pmmp1,somx2;
    int ll;

    if (m < 0 || m > l || fabs(x) > 1.0) {
        printf("ERROR: Bad arguments in routine legendre_poly"); exit(1);
    }

    pmm = 1.0;

    if (m > 0) {
        somx2=sqrt((1.0 - x)*(1.0 + x));
        fact=1.0;
        for (int i=1; i <= m; i++) {
            pmm *= -fact*somx2;
            fact += 2.0;
        }
    }

    if (l == m) {
        return pmm;
    } else {
        pmmp1 = x*(2*m+1)*pmm;
        if (l==(m+1)) {
            return pmmp1;
        } else {
            for (ll=m+2; ll<=l; ll++) {
                pll=(x*(2*ll-1)*pmmp1 - (ll+m-1)*pmm)/ (double) (ll-m);
                pmm = pmmp1;
                pmmp1= pll;

            }
            return pll;
        }
    }
}
double* getYlmi(double* x, double* y, double* z, double* oOri, double* cf, int icount, int lMax)
{
    double* Ylmi = (double*) malloc(2*sd*(lMax+1)*(lMax+1)*icount);
    double* legPol = (double*) malloc(sd*(lMax+1)*(lMax+1)*icount);
    double* ChiCos= (double*) malloc(sd*(lMax+1)*icount);
    double* ChiSin= (double*) malloc(sd*(lMax+1)*icount);
    double myAtan2;

    for (int i = 0; i < icount; i++) {
        for (int l = 0; l < lMax + 1; l++) {
            for (int m = 0; m < l+1; m++) {
                legPol[icount*(lMax+1)*l + icount*m + i] = legendre_poly(l,m,z[i]*oOri[i]);
            }
        }
        for (int m = 0; m < lMax+1; m++) {
            myAtan2 = m*atan2(y[i],x[i]);
            ChiCos[m*icount + i] = cos(myAtan2);
            ChiSin[m*icount + i] = sin(myAtan2);
        }
    }

    for (int l = 0; l < lMax+1; l++) {
        for (int m = 0; m < l+1; m++) {
            for (int i = 0; i < icount; i++) {
                Ylmi[2*(lMax+1)*icount*l + 2*icount*m + 2*i]
                    =  factorY(l,m,cf)*legPol[icount*(lMax+1)*l + icount*m + i]*ChiCos[m*icount + i];
                Ylmi[2*(lMax+1)*icount*l + 2*icount*m + 2*i + 1]
                    = factorY(l,m,cf)*legPol[icount*(lMax+1)*l + icount*m + i]*ChiSin[m*icount + i];
            }
        }
    }
    free(legPol);
    free(ChiCos);
    free(ChiSin);

    return Ylmi;
}
double* getIntegrand(double* Flir, double* Ylmi, int rsize, int icount, int lMax, double* weights)
{
    double* summed = (double*) malloc(2*sd*(lMax+1)*rsize*(lMax+1));
    double realY;
    double imagY;

    // Initialize to zero
    memset(summed, 0.0, 2*(lMax+1)*rsize*(lMax+1)*sizeof(double));

    for (int l = 0; l < lMax+1; l++) {
        for (int m = 0; m < l+1; m++) {
            for (int i = 0; i < icount; i++) {
                realY = Ylmi[2*(lMax+1)*icount*l + 2*icount*m + 2*i];
                imagY = Ylmi[2*(lMax+1)*icount*l + 2*icount*m + 2*i + 1];
                for (int rw = 0; rw < rsize; rw++) {
                    summed[2*(lMax+1)*l*rsize + 2*m*rsize + 2*rw    ] += weights[i]*Flir[l*rsize*icount + rsize*i + rw] * realY;
                    summed[2*(lMax+1)*l*rsize + 2*m*rsize + 2*rw + 1] += weights[i]*Flir[l*rsize*icount + rsize*i + rw] * imagY;
                }
            }
        }
    }
    return summed;
}
void getC(double* C, double* ws, double* rw2, double * gns, double* summed, double rCut, int lMax, int rsize, int gnsize, int nCenters, int nNeighbours, double eta, double* weights)
{
    // Initialize to zero
    memset(C, 0.0, 2*(lMax+1)*(lMax+1)*gnsize*sizeof(double));

    for (int n = 0; n < gnsize; n++) {
        // For atoms at the center we add a precalculated constant value
        // because the numerical integration cannot handle them
        if (nCenters > 0) {
            double weight = weights[nNeighbours];
            for (int iCenter = 0; iCenter < nCenters; ++iCenter) {
                for (int rw = 0; rw < rsize; rw++) {
                    C[2*(lMax+1)*(lMax+1)*n] += weight * 0.5*0.564189583547756*rw2[rw]*ws[rw]*gns[rsize*n + rw]*exp(-eta*rw2[rw]);
                }
            }
        }
        for (int l = 0; l < lMax+1; l++) {
            for (int m = 0; m < l+1; m++) {
                for (int rw = 0; rw < rsize; rw++) {
                    C[2*(lMax+1)*(lMax+1)*n + l*2*(lMax+1) + 2*m    ] += rw2[rw]*ws[rw]*gns[rsize*n + rw]*summed[2*(lMax+1)*l*rsize + 2*m*rsize + 2*rw    ]; // Re
                    C[2*(lMax+1)*(lMax+1)*n + l*2*(lMax+1) + 2*m + 1] += rw2[rw]*ws[rw]*gns[rsize*n + rw]*summed[2*(lMax+1)*l*rsize + 2*m*rsize + 2*rw + 1]; //Im
                }
            }
        }
    }
}

void accumC(double* Cs, double* C, int lMax, int nMax, int typeI, int i, int nCoeffs)
{
    for (int n = 0; n < nMax; n++) {
        for (int l = 0; l < lMax+1; l++) {
            for (int m = 0; m < l+1; m++) {
                Cs[i*nCoeffs+2*typeI*(lMax+1)*(lMax+1)*nMax +2*(lMax+1)*(lMax+1)*n + l*2*(lMax+1) + 2*m    ] = C[2*(lMax+1)*(lMax+1)*n + l*2*(lMax+1) + 2*m    ];
                Cs[i*nCoeffs+2*typeI*(lMax+1)*(lMax+1)*nMax +2*(lMax+1)*(lMax+1)*n + l*2*(lMax+1) + 2*m + 1] = C[2*(lMax+1)*(lMax+1)*n + l*2*(lMax+1) + 2*m + 1];
            }
        }
    }
}

/**
 * Used to calculate the partial power spectrum.
 *
 * The power spectrum is multiplied by an l-dependent prefactor
 * PI*sqrt(8.0/(2.0*l+1.0)); that comes from the normalization of the Wigner D
 * matrices. This prefactor is mentioned in the errata of the original SOAP
 * paper: On representing chemical environments, Phys. Rev. B 87, 184115
 * (2013). Here the square root of the prefactor in the dot-product kernel is
 * used, so that after a possible dot-product the full prefactor is recovered.
 */
void getP(py::detail::unchecked_mutable_reference<double, 2> &Ps, double* Cs, int Nt, int lMax, int nMax, int Hs, double rCut2, int nFeatures, bool crossover, int nCoeffs)
{
    // The current index in the final power spectrum array.
    int pIdx = 0;

    for (int i = 0; i < Hs; i++) {
        pIdx = 0;
        for (int Z1 = 0; Z1 < Nt; Z1++) {
            int Z2Limit = crossover ? Nt : Z1+1;
            for (int Z2 = Z1; Z2 < Z2Limit; Z2++) {
                // If the species are identical, then there is symmetry in the
                // radial basis and we only loop N2 from N1 to nMax
                if (Z1 == Z2) {
                    for (int l = 0; l < lMax+1; l++) {
                        for (int N1 = 0; N1 < nMax; N1++) {
                            for (int N2 = N1; N2 < nMax; N2++) {
                                double sum = 0;
                                for (int m = 0; m < l+1; m++) {
                                    if (m == 0) {
                                        sum += Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1)] // m=0
                                            *Cs[i*nCoeffs+2*Z2*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1)]; // m=0
                                    } else {
                                        sum += 2*(Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1) + 2*m]
                                                *Cs[i*nCoeffs+2*Z2*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1) + 2*m]
                                                +Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1) + 2*m + 1]
                                                *Cs[i*nCoeffs+2*Z2*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1) + 2*m + 1]);
                                    }
                                }
                                Ps(i, pIdx) = PI*sqrt(8.0/(2.0*l+1.0))*39.478417604*rCut2*sum;  // Normalization and other constants
                                ++pIdx;
                            }
                        }
                    }
                // If the species are different, then there is no symmetry in the
                // radial basis and we have to loop over all pairwise combinations.
                } else {
                    for (int l = 0; l < lMax+1; l++) {
                        for (int N1 = 0; N1 < nMax; N1++) {
                            for (int N2 = 0; N2 < nMax; N2++) {
                                double sum = 0;
                                for (int m = 0; m < l+1; m++) {
                                    if (m == 0) {
                                        sum += Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1)] // m=0
                                            *Cs[i*nCoeffs+2*Z2*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1)]; // m=0
                                    } else {
                                        sum += 2*(Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1) + 2*m]
                                                *Cs[i*nCoeffs+2*Z2*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1) + 2*m]
                                                +Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1) + 2*m + 1]
                                                *Cs[i*nCoeffs+2*Z2*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1) + 2*m + 1]);
                                    }
                                }
                                Ps(i, pIdx) = PI*sqrt(8.0/(2.0*l+1.0))*39.478417604*rCut2*sum;  // Normalization and other constants
                                ++pIdx;
                            }
                        }
                    }
                }
            }
        }
    }
}


/**
 * Used to calculate the partial power spectrum with feature compression
 * as described in Darby et al. Currently only for the mu = 1, nu = 1
 * compression described in Darby et al. (by far the best performing
 * alternative that they evaluated). It could be adapted however to
 * provide other compression alternatives. This compression scheme
 * scales linearly with the number of elements and is thus far more
 * practical for many-element systems.
 *
 * The power spectrum is multiplied by an l-dependent prefactor
 * PI*sqrt(8.0/(2.0*l+1.0)); that comes from the normalization of the Wigner D
 * matrices. This prefactor is mentioned in the errata of the original SOAP
 * paper: On representing chemical environments, Phys. Rev. B 87, 184115
 * (2013). Here the square root of the prefactor in the dot-product kernel is
 * used, so that after a possible dot-product the full prefactor is recovered.
 */
void getPWithCompression(py::detail::unchecked_mutable_reference<double, 2> &Ps, double* Cs,
    double* CsSummed, int Nt, int lMax, int nMax, int Hs,
    double rCut2, int nFeatures, int nCoeffs, int nCompressionCoeffs)
{
   // The current index in the final power spectrum array.
    int pIdx = 0;

    for (int i = 0; i < Hs; i++) {
        pIdx = 0;
        for (int Z1 = 0; Z1 < Nt; Z1++) {
            for (int l = 0; l < lMax+1; l++) {
                for (int N1 = 0; N1 < nMax; N1++) {
                    for (int N2 = 0; N2 < nMax; N2++) {
                        double sum = 0;
                        for (int m = 0; m < l+1; m++) {
                            if (m == 0) {
                                sum += Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1)] // m=0
                                            *CsSummed[i*nCompressionCoeffs + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1)]; // m=0
                            } else {
                                sum += 2*(Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1) + 2*m]
                                                *CsSummed[i*nCompressionCoeffs + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1) + 2*m]
                                                +Cs[i*nCoeffs+2*Z1*(lMax+1)*(lMax+1)*nMax + 2*(lMax+1)*(lMax+1)*N1 + l*2*(lMax+1) + 2*m + 1]
                                                *CsSummed[i*nCompressionCoeffs + 2*(lMax+1)*(lMax+1)*N2 + l*2*(lMax+1) + 2*m + 1]);
                            }
                        }
                        Ps(i, pIdx) = PI*sqrt(8.0/(2.0*l+1.0))*39.478417604*rCut2*sum;  // Normalization and other constants
                        ++pIdx;
                    }
                }
            }
        }
    }
}





void soapGeneral(
    py::array_t<double> PsArr,
    py::array_t<double> positions,
    py::array_t<double> HposArr,
    py::array_t<int> atomicNumbersArr,
    py::array_t<int> orderedSpeciesArr,
    py::array_t<double> speciesWeightsArr,
    double rCut,
    double cutoffPadding,
    int nMax,
    int lMax,
    double eta,
    py::dict weighting,
    py::array_t<double> rwArr,
    py::array_t<double> gssArr,
    string average,
    string compression,
    CellList cellList)
{
    int nAtoms = atomicNumbersArr.shape(0);
    int Nt = orderedSpeciesArr.shape(0);
    int Hs = HposArr.shape(0);
    int nFeatures = 0;
    bool crossover = true;
    if ( compression == "mu1nu1" ){
        nFeatures = Nt*(lMax+1)*(nMax*nMax);
    } else if( compression == "mu2" ){
        Nt = 1;
        nFeatures = nMax*(nMax+1)*(lMax+1)/2;
    } else if ( compression == "crossover" ){
        crossover = false;
        nFeatures = Nt*(lMax+1)*((nMax+1)*nMax)/2;
    } else{
        nFeatures = (Nt*nMax)*(Nt*nMax+1)*(lMax+1)/2;
    }
    auto atomicNumbers = atomicNumbersArr.unchecked<1>();
    auto species = orderedSpeciesArr.unchecked<1>();
    auto Ps = PsArr.mutable_unchecked<2>();
    auto speciesWeights = speciesWeightsArr.unchecked<1>();
    double *Hpos = (double*)HposArr.request().ptr;
    double *rw = (double*)rwArr.request().ptr;
    double *gss = (double*)gssArr.request().ptr;
    double* cf = factorListSet();
    const int rsize = 100; // The number of points in the radial integration grid
    double rCut2 = rCut*rCut;
    double* dx = tot;
    double* dy = tot;
    double* dz = tot;
    double* ris = tot;
    double* weights = tot;
    double* oOri = tot;
    double* ws  = getws();
    double* oOr = getoOr(rw, rsize);
    double* rw2 = getrw2(rw, rsize);
    double* oO4arri = totrs;
    double* minExp = totrs;
    double* pluExp = totrs;
    double* C = (double*) malloc(2*sd*(lMax+1)*(lMax+1)*nMax);
    
    // Initialize arrays for storing the C coefficients.
    int nCoeffs = 2*(lMax+1)*(lMax+1)*nMax*Nt;
    int nCompressionCoeffs = 0;
    int nCoeffsAll = nCoeffs*Hs;
    double* Cs = (double*) malloc(sizeof(double)*nCoeffsAll);
    double* CsAve;
    memset(Cs, 0.0, nCoeffsAll*sizeof(double));
    if (average == "inner") {
        CsAve = (double*) malloc(nCoeffs*sizeof(double));
        memset(CsAve, 0.0, nCoeffs*sizeof(double));
    }
    double* CsCompressed;
    if (compression == "mu1nu1") {
        if (average == "inner"){
            nCompressionCoeffs = 2*(lMax+1)*(lMax+1)*nMax;
            CsCompressed = (double*) malloc(nCompressionCoeffs*sizeof(double));
            memset(CsCompressed, 0.0, nCompressionCoeffs*sizeof(double));
        } else{
            nCompressionCoeffs = 2*(lMax+1)*(lMax+1)*nMax;
            CsCompressed = (double*) malloc(Hs*nCompressionCoeffs*sizeof(double));
            memset(CsCompressed, 0.0, Hs*nCompressionCoeffs*sizeof(double));
        }
    }

    // Create a mapping between an atomic index and its internal index in the
    // output. The list of species is already ordered.
    map<int, int> ZIndexMap;
    for (int i = 0; i < species.size(); ++i) {
        ZIndexMap[species(i)] = i;
    }

    // Loop through central points
    for (int i = 0; i < Hs; i++) {

        // Get all neighbours for the central atom i
        double ix = Hpos[3*i];
        double iy = Hpos[3*i+1];
        double iz = Hpos[3*i+2];
        CellListResult result = cellList.getNeighboursForPosition(ix, iy, iz);

        // Sort the neighbours by type, unless using mu2 compression, in
        // which case we essentially assume all neighbors are same type (except
        // for weighting purposes).
        if (compression != "mu2"){
            map<int, vector<int>> atomicTypeMap;
            for (const int &idx : result.indices) {
                int Z = atomicNumbers(idx);
                atomicTypeMap[Z].push_back(idx);
            };
            // Loop through neighbours sorted by type
            for (const auto &ZIndexPair : atomicTypeMap) {

                // j is the internal index for this atomic number
                int j = ZIndexMap[ZIndexPair.first];

                double* Ylmi; double* Flir; double* summed;

                // Notice that due to the numerical integration the getDeltas
                // function here has special functionality for positions that are
                // centered on an atom.
                pair<int, int> neighbours = getDeltas(dx, dy, dz, ris, rw, rCut, oOri, oO4arri, minExp, pluExp, eta, positions, ix, iy, iz, ZIndexPair.second, rsize, i, j);
                int nNeighbours = neighbours.first;
                int nCenters = neighbours.second;

                getWeights(nNeighbours + min(nCenters, 1), ris, NULL, false, weighting, weights);
                //Multiply all of the weights by the element-specific weights (default to 1).
                //This enables straightforward implementation of element-specific weighting
                //if so specified by user.
                for(std::size_t k = 0; k < ZIndexPair.second.size(); ++k){
                    int Z = atomicNumbers(ZIndexPair.second[k]);
                    int speciesIdx = ZIndexMap[Z];
                    double weight = speciesWeights(speciesIdx);
                    weights[k] *= weight;
                }

                Flir = getFlir(oO4arri, ris, minExp, pluExp, nNeighbours, rsize, lMax);
                Ylmi = getYlmi(dx, dy, dz, oOri, cf, nNeighbours, lMax);
                summed = getIntegrand(Flir, Ylmi, rsize, nNeighbours, lMax, weights);

                getC(C, ws, rw2, gss, summed, rCut, lMax, rsize, nMax, nCenters, nNeighbours, eta, weights);
                accumC(Cs, C, lMax, nMax, j, i, nCoeffs);
            
                free(Flir);
                free(Ylmi);
                free(summed);
            }
        } else {
            double* Ylmi; double* Flir; double* summed;

            // Notice that due to the numerical integration the getDeltas
            // function here has special functionality for positions that are
            // centered on an atom.
            pair<int, int> neighbours = getDeltas(dx, dy, dz, ris, rw, rCut, oOri, oO4arri, minExp, pluExp, eta, positions, ix, iy, iz, result.indices, rsize, i, 0);
            int nNeighbours = neighbours.first;
            int nCenters = neighbours.second;

            getWeights(nNeighbours + min(nCenters, 1), ris, NULL, false, weighting, weights);
            //Multiply all of the weights by the element-specific weights (default to 1).
            //This enables straightforward implementation of element-specific weighting
            //if so specified by user.
            for(std::size_t k = 0; k < result.indices.size(); ++k){
                int Z = atomicNumbers(result.indices[k]);
                int speciesIdx = ZIndexMap[Z];
                double weight = speciesWeights(speciesIdx);
                weights[k] *= weight;
            }

            Flir = getFlir(oO4arri, ris, minExp, pluExp, nNeighbours, rsize, lMax);
            Ylmi = getYlmi(dx, dy, dz, oOri, cf, nNeighbours, lMax);
            summed = getIntegrand(Flir, Ylmi, rsize, nNeighbours, lMax, weights);

            getC(C, ws, rw2, gss, summed, rCut, lMax, rsize, nMax, nCenters, nNeighbours, eta, weights);
            accumC(Cs, C, lMax, nMax, 0, i, nCoeffs);
            
            free(Flir);
            free(Ylmi);
            free(summed);
        }
    }

    // If inner averaging is requested, average the coefficients over the
    // positions (axis 0 in cnnd matrix) before calculating the power spectrum.
    if (average == "inner") {
        for (int i = 0; i < Hs; i++) {
            for (int j = 0; j < nCoeffs; j++) {
                CsAve[j] += Cs[i*nCoeffs + j];
            }
        }
        for (int j = 0; j < nCoeffs; j++) {
            CsAve[j] = CsAve[j] / (double)Hs;
        }
        if (compression == "mu1nu1"){
            for (int j = 0; j < Nt; j++) {
                for (int k = 0; k < nMax; k++){
                    for (int l = 0; l < 2 * (lMax + 1) * (lMax + 1); l++){
                        int inputPosition = 2*j*(lMax+1)*(lMax+1)*nMax +
                                2*k*(lMax+1)*(lMax+1) + l;
                        int outputPosition = 2*k*(lMax+1)*(lMax+1) + l;
                        CsCompressed[outputPosition] += CsAve[inputPosition];
                    }
                }
            }
            getPWithCompression(Ps, CsAve, CsCompressed, Nt, lMax, nMax, 1, rCut2, nFeatures,
                        nCoeffs, nCompressionCoeffs);
            free(CsCompressed);
        }
        else{
            getP(Ps, CsAve, Nt, lMax, nMax, 1, rCut2, nFeatures, crossover, nCoeffs);
        }
    // Average the power spectrum across atoms
    } else if (average == "outer") {
        // We allocate the memory and give array_t a pointer to it. This way
        // the memory is owned and freed by C++.
        double* PsTemp = new double[nFeatures*Hs];
        py::array_t<double> PsTempArrChecked({Hs, nFeatures}, PsTemp);
        auto PsTempArr = PsTempArrChecked.mutable_unchecked<2>();

        if (compression == "mu1nu1"){
            for (int i = 0; i < Hs; i++) {
                for (int j = 0; j < Nt; j++) {
                    for (int k = 0; k < nMax; k++){
                        for (int l = 0; l < 2 * (lMax + 1) * (lMax + 1); l++){
                            int inputPosition = i*nCoeffs + 2*j*(lMax+1)*(lMax+1)*nMax +
                                2*k*(lMax+1)*(lMax+1) + l;
                            int outputPosition = i*nCompressionCoeffs + 2*k*(lMax+1)*(lMax+1) + l;
                            CsCompressed[outputPosition] += Cs[inputPosition];
                        }
                    }
                }
            }
            getPWithCompression(PsTempArr, Cs, CsCompressed, Nt, lMax, nMax, Hs, rCut2, nFeatures,
                        nCoeffs, nCompressionCoeffs);
            free(CsCompressed);
        }
        else {
            getP(PsTempArr, Cs, Nt, lMax, nMax, Hs, rCut2, nFeatures, crossover, nCoeffs);
        }

        for (int i = 0; i < Hs; i++) {
            for (int j = 0; j < nFeatures; j++) {
                Ps(0, j) += PsTempArr(i, j);
            }
        }
        for (int j = 0; j < nFeatures; j++) {
            Ps(0, j) = Ps(0, j) / (double)Hs;
        }
        free(PsTemp);
    // Regular power spectrum without averaging
    } else {
        if (compression == "mu1nu1"){
            for (int i = 0; i < Hs; i++) {
                for (int j = 0; j < Nt; j++) {
                    for (int k = 0; k < nMax; k++){
                        for (int l = 0; l < 2 * (lMax + 1) * (lMax + 1); l++){
                            int inputPosition = i*nCoeffs + 2*j*(lMax+1)*(lMax+1)*nMax +
                                2*k*(lMax+1)*(lMax+1) + l;
                            int outputPosition = i*nCompressionCoeffs + 2*k*(lMax+1)*(lMax+1) + l;
                            CsCompressed[outputPosition] += Cs[inputPosition];
                        }
                    }
                }
            }
            getPWithCompression(Ps, Cs, CsCompressed, Nt, lMax, nMax, Hs, rCut2, nFeatures,
                        nCoeffs, nCompressionCoeffs);
            free(CsCompressed);
        } else {
            getP(Ps, Cs, Nt, lMax, nMax, Hs, rCut2, nFeatures, crossover, nCoeffs);
        }
    }

    free(Cs);
    free(cf);
    free(dx);
    free(dy);
    free(dz);
    free(ris);
    free(oOri);
    free(ws);
    free(oOr);
    free(rw2) ;
    free(oO4arri);
    free(minExp);
    free(pluExp);
    free(C);
}
